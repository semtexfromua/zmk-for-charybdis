on: [push, pull_request, workflow_dispatch]

jobs: # Визначення job'ів
  build_job: # Job 1: Виконує збірку за допомогою reusable workflow
    name: Build ZMK Firmware # Назва job збірки (можете змінити)
    runs-on: ubuntu-latest # Вказуємо runner для цього job (може бути перевизначено у reusable workflow, але краще вказати)

    steps: # Кроки всередині job 'build_job'
      - name: Checkout Code # Крок для клонування коду (необхідний для build-user-config.yml)
        uses: actions/checkout@v4

      # Цей крок ВИКЛИКАЄ багаторазовий робочий процес build-user-config.yml.
      # Всі кроки build-user-config.yml виконуються всередині цього job.
      - name: Run Reusable Build Workflow # Назва кроку, що викликає workflow
        id: reusable_build_step # <-- ДОДАЙТЕ id до цього кроку uses
        uses: zmkfirmware/zmk/.github/workflows/build-user-config.yml@main
        with:
          # ПЕРЕДАЙТЕ СЮДИ ВСІ ВАШІ ІСНУЮЧІ ПАРАМЕТРИ для build-user-config.yml
          # (board, shield, zmk_config, можливо artifact_name якщо ви його вказували)
          # Приклад:
          board: nice_nano_v2
          shield: charybdis_right
          zmk_config: ${{ github.workspace }}/config
          # artifact_name: firmware # Якщо ви раніше використовували цей параметр у build-user-config.yml

    # --- КІНЕЦЬ job 'build_job' ---

  upload_config_job: # Job 2: Запускається ПІСЛЯ 'build_job' для завантаження конфігу
    name: Upload Build Config # Назва job (можете змінити)
    runs-on: ubuntu-latest # Цей job теж потребує runner
    needs: build_job # <-- Цей job залежить від успішного завершення 'build_job'

    steps: # Кроки всередині job 'upload_config_job'
      - name: Download build artifacts # Крок для завантаження артефактів з попереднього job
        uses: actions/download-artifact@v4
        with:
          # Ім'я артефакту, яке було використано для завантаження firmware у reusable workflow
          # build-user-config.yml зазвичай завантажує firmware артефакт за замовчуванням з назвою 'firmware'
          # Якщо ви вказували `artifact_name` у параметрах reusable workflow, використовуйте це ім'я тут
          name: firmware # <-- Ймовірна назва артефакту firmware за замовчуванням. Перевірте документацію або логи build-user-config.yml
          path: downloaded_artifacts # Шлях, куди завантажити артефакти в цьому job

      - name: List downloaded files (for debugging) # Необов'язковий крок для перевірки вмісту
        run: |
          echo "Listing files in downloaded_artifacts:"
          ls -R downloaded_artifacts

      - name: Find and Upload .config file # Крок для знаходження та завантаження .config
        run: |
          # Знаходимо .config файл у завантажених артефактах
          CONFIG_FILE=$(find downloaded_artifacts -name ".config")
          if [ -f "$CONFIG_FILE" ]; then
            echo "Found .config at: $CONFIG_FILE"
            # Завантажуємо .config як новий артефакт
            # Використовуємо actions/upload-artifact ще раз
            # Цього разу path має бути до знайденого .config файлу
            # Використовуємо іншу назву артефакту, щоб уникнути плутанини
            echo "Uploading .config as artifact..."
            actions/upload-artifact@v4 --name final-build-config-${{ github.event.pull_request.number }}-${{ github.sha }} --path "$CONFIG_FILE"
            echo "Upload command executed. Check artifacts section."
          else
            echo ".config file not found in downloaded artifacts!"
            # exit 1 # Можете розкоментувати, якщо хочете, щоб job падав, якщо конфіг не знайдено
          fi
        shell: bash # Вказуємо оболонку для виконання скрипта

    # --- КІНЕЦЬ job 'upload_config_job' ---
